#!/bin/bash
# ARG_OPTIONAL_BOOLEAN([base],[b],[Run base module],[true])
# ARG_OPTIONAL_BOOLEAN([selfupdate],[],[Update set-me-up],[])
# ARG_OPTIONAL_BOOLEAN([provision],[p],[Provision with given modules (default all)],[off])
# ARG_OPTIONAL_REPEATED([modules],[m],[Modules to provision, all if none given])
# ARG_HELP([set-me-up installer])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='bpmh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_base="on"
_arg_selfupdate="off"
_arg_provision="off"
_arg_modules=()

print_help ()
{
	printf '%s\n' "set-me-up installer"
	printf 'Usage: %s [-b|--(no-)base] [--(no-)selfupdate] [-p|--(no-)provision] [-m|--modules <arg>] [-h|--help]\n' "$0"
	printf '\t%s\n' "-b,--base,--no-base: Run base module (on by default)"
	printf '\t%s\n' "--selfupdate,--no-selfupdate: Update set-me-up (off by default)"
	printf '\t%s\n' "-p,--provision,--no-provision: Provision with given modules (default all) (off by default)"
	printf '\t%s\n' "-m,--modules: Modules to provision, all if none given (empty by default)"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-b|--no-base|--base)
				_arg_base="on"
				test "${1:0:5}" = "--no-" && _arg_base="off"
				;;
			-b*)
				_arg_base="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--no-selfupdate|--selfupdate)
				_arg_selfupdate="on"
				test "${1:0:5}" = "--no-" && _arg_selfupdate="off"
				;;
			-p|--no-provision|--provision)
				_arg_provision="on"
				test "${1:0:5}" = "--no-" && _arg_provision="off"
				;;
			-p*)
				_arg_provision="on"
				_next="${_key##-p}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-p" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-m|--modules)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_modules+=("$2")
				shift
				;;
			--modules=*)
				_arg_modules+=("${_key##--modules=}")
				;;
			-m*)
				_arg_modules+=("${_key##-m}")
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

readonly module_path="${HOME}/.modules"

provision_enabled() {
    [[ ${_arg_provision} == "on" ]]
}

export _arg_provision
export -f provision_enabled

start_sudo() {
    sudo -v
    ( while true; do sudo -v; sleep 60; done; ) &
    SUDO_PID="$!"
    trap stop_sudo SIGINT SIGTERM
}

stop_sudo() {
    kill "$SUDO_PID"
    trap - SIGINT SIGTERM
    sudo -k
}

provision_module() {
    # source base from installation directory
    # this enables smu to work on first time installations
    if [[ "${module}" == "base" ]]; then
        local -r path="./.dotfiles/base"
    else
        local -r path="${module_path}/${1}"
    fi

    local -r script="${1}.sh"
    local -r requires_sudo=("macos" "macosupdate")

    if [[ ! -e "${path}/${script}" ]]; then
        echo "${path}/${script} does not seem to exist, skipping."
        false
        return
    fi

    echo "Running ${path}/${script} module"

    if [[ " ${requires_sudo[@]} " =~ " ${1}" ]]; then
        ( cd "${path}/" && start_sudo && source "./${script}" && stop_sudo )
    else
        ( cd "${path}/" && source "./${script}" )
    fi
}


if [[ ${_arg_selfupdate} == "on" ]]; then
    ${module_path}/update.sh

    ! provision_enabled && exit 0
fi

if ! provision_enabled ; then
    _PRINT_HELP=yes die "Please provide the --provision switch to run set-me-up." 1
    exit 0
fi

read -p "set-me-up may overwrite existing files in your home directory. Are you sure? (y/n) " -n 1;
echo "";
[[ ! $REPLY =~ ^[Yy]$ ]] && exit 0

modules=("${_arg_modules[@]}")

# enable all known modules
if [[ ${#_arg_modules[@]} = 0 || " ${_arg_modules[@]} " =~ " all " ]]; then
    modules=("macosupdate" "essentials" "macos" "terminal" "php" "ruby" "${modules[@]}")
fi

# by default run the base module as early as possible
if [[ ${_arg_base} == "on" ]]; then
    modules=("base" "${modules[@]}")
fi

# check if macosupdate is contained in module list and if so queue it at the beginning
if [[ " ${modules[@]} " =~ " macosupdate " ]]; then
    modules=("macosupdate" "${modules[@]}")
fi

# list of executed modules, so we only one run them once
done=("all")

# run modules
for module in "${modules[@]}"
do
    if [[ ! " ${done[@]} " =~ " ${module} " ]]; then
        provision_module "${module}"
        done=("${module}" "${done[@]}")
    fi
done

echo "------------------------------"
echo "Completed running set-me-up, restart your computer to ensure all updates take effect."
echo "------------------------------"


# ] <-- needed because of Argbash
